<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MyAnimeList - Anime List</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #111;
    color: #eee;
    margin: 0;
    padding: 20px;
  }
  .container {
    max-width: 900px;
    margin: auto;
  }
  header {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1.5rem;
    gap: 0.5rem;
    column-gap: 1rem;
  }
  header h1 {
    margin: 0;
    font-weight: 700;
  }
  .user-actions {
    display: flex;
    gap: 0.8rem;
  }
  .user-actions button {
    background-color: #282828;
    border: none;
    color: #61dafb;
    font-weight: 600;
    padding: 0.4rem 0.9rem;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.2s ease;
    font-size: 0.9rem;
  }
  .user-actions button:hover,
  .user-actions button:focus {
    background-color: #3a3a3a;
    outline: none;
  }
  #addAnimeBtn {
    background-color: #3cb371;
    border: none;
    color: #111;
    font-weight: 700;
    padding: 0.5rem 1rem;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.2s ease;
  }
  #addAnimeBtn:hover,
  #addAnimeBtn:focus {
    background-color: #35995f;
    outline: none;
  }
  #searchInput {
    width: 100%;
    padding: 10px;
    font-size: 1rem;
    border-radius: 6px;
    border: 1px solid #555;
    background: #222;
    color: #eee;
    margin-bottom: 1.5rem;
    box-sizing: border-box;
  }
  .stats {
    display: flex;
    justify-content: space-around;
    background: #222;
    padding: 0.75rem 1rem;
    border-radius: 8px;
    margin-bottom: 1.5rem;
    font-weight: 600;
    color: #aaa;
    user-select: none;
    gap: 3rem;
  }
  .stats div {
    min-width: 120px;
    text-align: center;
  }
  section {
    margin-bottom: 40px;
  }
  h2 {
    border-bottom: 1px solid #555;
    padding-bottom: 6px;
    margin-bottom: 12px;
    font-weight: 700;
  }
  .anime-list {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
  }
  .anime-card, .favorite-card {
    background: #222;
    border-radius: 6px;
    padding: 10px;
    width: 230px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
  }
  .favorite-card {
    width: 160px;
  }
  .anime-poster {
    width: 100%;
    height: auto;
    border-radius: 6px;
    margin-bottom: 8px;
    flex-shrink: 0;
  }
  .anime-title, .favorite-card-title {
    font-size: 1.1em;
    font-weight: bold;
    margin-bottom: 6px;
  }
  .genre-tags {
    margin-bottom: 8px;
  }
  .genre-tag {
    background: #555;
    border-radius: 12px;
    padding: 2px 8px;
    font-size: 0.8em;
    margin-right: 4px;
    color: #ddd;
    display: inline-block;
  }
  .anime-note {
    font-style: italic;
    margin-bottom: 8px;
    font-size: 0.9em;
    color: #ccc;
    flex-grow: 1;
  }
  .episodes, .rating {
    font-size: 0.9em;
    margin-bottom: 6px;
  }
  .anime-progress {
    background: #333;
    border-radius: 8px;
    overflow: hidden;
    height: 10px;
    margin-bottom: 10px;
  }
  .progress-bar-fill {
    background: #3cb371;
    height: 100%;
    transition: width 0.3s ease;
  }
  .btn-group {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
  }
  .btn {
    padding: 6px 10px;
    background: #3cb371;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    color: #111;
    font-weight: bold;
  }
  .btn-secondary {
    background: #aa4444;
    color: #eee;
  }
  #modalOverlay { 
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
    background: rgba(0,0,0,0.75); display: none; justify-content: center; align-items: center; 
    z-index: 1000; 
  }
  #modalOverlay.active { display: flex; }
  #modal {
    background: #222; padding: 20px; border-radius: 8px; width: 400px; max-width: 90vw; color: #eee; position: relative;
  }
  #modalClose {
    position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 1.6em; color: #eee; cursor: pointer;
  }
  label {
    display: block; margin-top: 10px; font-weight: bold;
  }
  input[type="text"], input[type="number"], select, textarea, input[type="file"] {
    width: 100%; padding: 6px; margin-top: 4px; border-radius: 4px; border: 1px solid #555; background: #111; color: #eee;
    box-sizing: border-box;
  }
  textarea { resize: vertical; }
  .modal-buttons {
    margin-top: 20px;
    text-align: right;
  }
  .modal-buttons button {
    margin-left: 10px;
  }
  .cancel {
    background: #555 !important;
    color: #eee !important;
  }
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>MyAnimeList - Anime List</h1>
    <div class="user-actions">
      <button id="editProfileBtn">Edit Profile</button>
      <button id="logoutBtn">Logout</button>
    </div>
    <button id="addAnimeBtn">+ Add Anime</button>
  </header>

  <input type="search" id="searchInput" placeholder="Search anime by title..." aria-label="Search anime by title" />

  <div class="stats" id="stats">
    <div>Total Anime: <span id="totalAnimes">0</span></div>
    <div>Average Rating: <span id="avgRating">0</span></div>
    <div>Watched Episodes: <span id="totalTime">0</span></div>
  </div>

  <section aria-label="Watched Anime">
    <h2>Watched Anime</h2>
    <div id="watchedList" class="anime-list" role="list"></div>
  </section>

  <section aria-label="Favorite Anime">
    <h2>Favorite Anime</h2>
    <div id="favoriteList" class="anime-list" role="list"></div>
  </section>

  <section aria-label="Plan to Watch Anime">
    <h2>Plan to Watch</h2>
    <div id="planToWatchList" class="anime-list" role="list"></div>
  </section>
</div>

<!-- Modal -->
<div id="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
  <div id="modal">
    <button id="modalClose" aria-label="Close modal">&times;</button>
    <h2 id="modalTitle">Add Anime</h2>
    <form id="animeForm" enctype="multipart/form-data" novalidate>
      <label for="animeTitle">Title *</label>
      <input id="animeTitle" name="title" type="text" required autocomplete="off" />

      <label for="animeGenres">Genres *</label>
      <select id="animeGenres" name="genre" multiple required size="5" aria-describedby="genreHelp"></select>
      <small id="genreHelp">Hold Ctrl (Cmd on Mac) to select multiple genres</small>

      <label for="animeStatus">Status *</label>
      <select id="animeStatus" name="status" required>
        <option value="">-- Select status --</option>
        <option value="Watched">Watched</option>
        <option value="Favorite">Favorite</option>
        <option value="Plan to Watch">Plan to Watch</option>
        <option value="Dropped">Dropped</option>
      </select>

      <label for="totalEpisodesInput">Total Episodes *</label>
      <input id="totalEpisodesInput" name="episodes" type="number" min="1" required />

      <label for="watchedEpisodesInput">Episodes Watched</label>
      <input id="watchedEpisodesInput" name="watchedEpisodes" type="number" min="0" />

      <label for="ratingInput">Rating (1.0 - 10.0)</label>
      <input id="ratingInput" name="rating" type="number" step="0.1" min="1" max="10" />

      <label for="notesInput">Notes</label>
      <textarea id="notesInput" name="note" rows="3" placeholder="Optional notes about the anime"></textarea>

      <label>
        <input id="favoriteInput" name="favorite" type="checkbox" />
        Mark as favorite
      </label>

      <label for="posterUrlInput">Upload Poster Image</label>
      <input id="posterUrlInput" name="image" type="file" accept="image/*" />

      <div class="modal-buttons">
        <button type="submit" id="modalSaveBtn">Save</button>
        <button type="button" id="modalCancel" class="cancel">Cancel</button>
      </div>
    </form>
  </div>
</div>

<script>
(() => {
  const genres = [
    "Action", "Adventure", "Comedy", "Drama", "Fantasy",
    "Historical", "Horror", "Magic", "Mecha", "Music",
    "Mystery", "Psychological", "Romance", "Sci-Fi", "Slice of Life",
    "Sports", "Supernatural", "Thriller"
  ];

  let animeList = [];
  let searchTerm = '';
  let editId = null;

  const searchInput = document.getElementById('searchInput');
  const totalAnimesEl = document.getElementById('totalAnimes');
  const avgRatingEl = document.getElementById('avgRating');
  const totalTimeEl = document.getElementById('totalTime');

  const watchedListEl = document.getElementById('watchedList');
  const favoriteListEl = document.getElementById('favoriteList');
  const planToWatchListEl = document.getElementById('planToWatchList');

  const modalOverlay = document.getElementById('modalOverlay');
  const modalCloseBtn = document.getElementById('modalClose');
  const modalCancelBtn = document.getElementById('modalCancel');
  const animeForm = document.getElementById('animeForm');

  const animeTitleInput = document.getElementById('animeTitle');
  const animeGenresSelect = document.getElementById('animeGenres');
  const animeStatusSelect = document.getElementById('animeStatus');
  const totalEpisodesInput = document.getElementById('totalEpisodesInput');
  const watchedEpisodesInput = document.getElementById('watchedEpisodesInput');
  const ratingInput = document.getElementById('ratingInput');
  const notesInput = document.getElementById('notesInput');
  const favoriteInput = document.getElementById('favoriteInput');
  const posterUrlInput = document.getElementById('posterUrlInput');

  const btnAddAnime = document.getElementById('addAnimeBtn');
  const btnLogout = document.getElementById('logoutBtn');
  const btnEditProfile = document.getElementById('editProfileBtn');

  function createElement(tag, className, props = {}) {
    const el = document.createElement(tag);
    if (className) el.className = className;
    Object.entries(props).forEach(([k,v]) => {
      if (k === 'text') el.textContent = v;
      else el.setAttribute(k, v);
    });
    return el;
  }
  function formatRating(num) {
    return num ? num.toFixed(1) : 'N/A';
  }
  function formatEpisodes(watched, total) {
    return `${watched}/${total}`;
  }
  function truncateText(text, maxLength = 80) {
    return text.length > maxLength ? text.slice(0, maxLength - 3) + '...' : text;
  }
  function avg(arr) {
    if (arr.length === 0) return 0;
    return arr.reduce((a,b) => a+b,0) / arr.length;
  }

  function renderAnimeList() {
    // Clear current lists
    watchedListEl.innerHTML = '';
    favoriteListEl.innerHTML = '';
    planToWatchListEl.innerHTML = '';

    // Filter based on search
    const filtered = animeList.filter(a => a.title.toLowerCase().includes(searchTerm));

    // Group by status
    const watched = filtered.filter(a => a.status === 'Watched');
    const favorite = filtered.filter(a => a.status === 'Favorite');
    const planToWatch = filtered.filter(a => a.status === 'Plan to Watch');

    // Render function for each list
    function renderCards(list, container, cardClass) {
      if(list.length === 0) {
        container.innerHTML = '<p>No anime found.</p>';
        return;
      }
      list.forEach(anime => {
        const card = createElement('article', cardClass, { role: 'listitem', tabIndex: 0, 'aria-label': anime.title });
        
        // Image
        if(anime.image){
          const img = createElement('img', 'anime-poster');
          img.src = `/static/uploads/${anime.image}`;
          img.alt = anime.title + " poster";
          card.appendChild(img);
        }

        // Title
        const titleEl = createElement('h3', cardClass === 'favorite-card' ? 'favorite-card-title' : 'anime-title', { text: anime.title });
        card.appendChild(titleEl);

        // Genres tags
        if (anime.genre) {
          const genresContainer = createElement('div', 'genre-tags');
          anime.genre.split(',').forEach(g => {
            if(g.trim() !== '') {
              const tag = createElement('span', 'genre-tag', { text: g.trim() });
              genresContainer.appendChild(tag);
            }
          });
          card.appendChild(genresContainer);
        }

        // Note
        if (anime.note) {
          const noteEl = createElement('p', 'anime-note', { text: truncateText(anime.note, 120) });
          card.appendChild(noteEl);
        }

        // Episodes info
        if (anime.status === 'Watched') {
          // Show watched episodes count equals total episodes (by backend logic)
          const ep = createElement('p', 'episodes', { text: `Episodes Watched: ${anime.episodes}` });
          card.appendChild(ep);
        } else {
          const ep = createElement('p', 'episodes', { text: `Total Episodes: ${anime.episodes}` });
          card.appendChild(ep);
        }

        // Rating if > 0
        if (anime.rating && anime.rating > 0) {
          const rate = createElement('p', 'rating', { text: `Rating: ${formatRating(anime.rating)}` });
          card.appendChild(rate);
        }

        // Buttons: Edit, Delete
        const btnGroup = createElement('div', 'btn-group');
        const btnEdit = createElement('button', 'btn');
        btnEdit.textContent = 'Edit';
        btnEdit.addEventListener('click', () => openEditModal(anime.id));
        btnGroup.appendChild(btnEdit);

        const btnDelete = createElement('button', 'btn btn-secondary');
        btnDelete.textContent = 'Delete';
        btnDelete.addEventListener('click', () => deleteAnime(anime.id));
        btnGroup.appendChild(btnDelete);

        card.appendChild(btnGroup);
        container.appendChild(card);
      });
    }

    renderCards(watched, watchedListEl, 'anime-card');
    renderCards(favorite, favoriteListEl, 'favorite-card');
    renderCards(planToWatch, planToWatchListEl, 'anime-card');

    updateStats(filtered);
  }

  function updateStats(filteredList) {
    totalAnimesEl.textContent = filteredList.length;

    const ratings = filteredList.filter(a => a.rating > 0).map(a => a.rating);
    avgRatingEl.textContent = ratings.length ? (ratings.reduce((a,b) => a+b, 0) / ratings.length).toFixed(2) : '0';

    // Sum watched episodes from all watched or favorite anime (status could be watched or favorite)
    const watchedEpisodes = filteredList
      .filter(a => a.status === 'Watched' || a.status === 'Favorite')
      .reduce((sum, a) => sum + (a.episodes || 0), 0);

    totalTimeEl.textContent = watchedEpisodes;
  }

  async function fetchAnimeList() {
    try {
      const resp = await fetch('/api/animelist');
      if (!resp.ok) throw new Error('Failed to fetch anime list.');
      const data = await resp.json();
      animeList = data.animes.map(a => ({
        id: a.id,
        title: a.title,
        genre: a.genre,
        status: a.status,
        episodes: a.episodes,
        rating: a.rating,
        note: a.note,
        image: a.image
      }));
      renderAnimeList();
    } catch (err) {
      alert(err.message || 'Error loading anime list.');
    }
  }

  function openModal() {
    modalOverlay.classList.add('active');
    animeForm.reset();
    editId = null;
    modalOverlay.querySelector('#modalTitle').textContent = 'Add Anime';
    watchedEpisodesInput.value = '';
  }

  function closeModal() {
    modalOverlay.classList.remove('active');
  }

  function openEditModal(id) {
    const anime = animeList.find(a => a.id === id);
    if (!anime) return alert('Anime not found.');

    editId = id;
    modalOverlay.classList.add('active');
    modalOverlay.querySelector('#modalTitle').textContent = 'Edit Anime';

    animeTitleInput.value = anime.title;
    animeGenresSelect.selectedIndex = -1;
    [...animeGenresSelect.options].forEach(opt => {
      opt.selected = anime.genre?.split(',').map(g => g.trim()).includes(opt.value);
    });
    animeStatusSelect.value = anime.status || '';
    totalEpisodesInput.value = anime.episodes || '';
    watchedEpisodesInput.value = anime.status === 'Watched' ? anime.episodes : '';
    ratingInput.value = anime.rating || '';
    notesInput.value = anime.note || '';
    favoriteInput.checked = anime.status === 'Favorite';
    posterUrlInput.value = '';
  }

  async function deleteAnime(id) {
    if (!confirm('Are you sure you want to delete this anime?')) return;
    try {
      const resp = await fetch(`/animelist/delete/${id}`, { method: 'POST' });
      if (!resp.ok) throw new Error('Failed to delete anime.');
      animeList = animeList.filter(a => a.id !== id);
      renderAnimeList();
    } catch (err) {
      alert(err.message || 'Error deleting anime.');
    }
  }

  async function submitForm(event) {
    event.preventDefault();

    // Validate required fields
    if (!animeTitleInput.value.trim()) {
      alert('Title is required.');
      animeTitleInput.focus();
      return;
    }
    if (!animeStatusSelect.value) {
      alert('Status is required.');
      animeStatusSelect.focus();
      return;
    }
    if (!totalEpisodesInput.value || totalEpisodesInput.value <= 0) {
      alert('Total episodes must be at least 1.');
      totalEpisodesInput.focus();
      return;
    }

    // Prepare form data
    const formData = new FormData();
    formData.append('title', animeTitleInput.value.trim());

    // Genres comma-separated string
    const selectedGenres = [...animeGenresSelect.selectedOptions].map(opt => opt.value);
    formData.append('genre', selectedGenres.join(','));

    formData.append('status', animeStatusSelect.value);
    formData.append('episodes', totalEpisodesInput.value);

    // Note: watched episodes input is for user info only, backend uses episodes for watched
    formData.append('note', notesInput.value.trim());

    formData.append('rating', ratingInput.value || 0);

    // If favorite is checked, override status to Favorite
    if (favoriteInput.checked) {
      formData.set('status', 'Favorite');
    }

    if (posterUrlInput.files.length > 0) {
      formData.append('image', posterUrlInput.files[0]);
    }

    try {
      let url = '/animelist/add';
      if (editId) {
        url = `/animelist/edit/${editId}`;
      }

      const resp = await fetch(url, {
        method: 'POST',
        body: formData
      });
      const data = await resp.json();
      if (!resp.ok || data.error) throw new Error(data.error || 'Failed to save anime.');

      if (editId) {
        // Update local animeList entry
        const index = animeList.findIndex(a => a.id === editId);
        if (index !== -1) {
          // Fetch updated anime data from server for image etc.
          await fetchAnimeList();
        }
      } else {
        // Add new anime to local list
        if (data.anime) animeList.push(data.anime);
      }

      renderAnimeList();
      closeModal();
    } catch (err) {
      alert(err.message || 'Error saving anime.');
    }
  }

  function populateGenres() {
    animeGenresSelect.innerHTML = '';
    genres.forEach(g => {
      const opt = document.createElement('option');
      opt.value = g;
      opt.textContent = g;
      animeGenresSelect.appendChild(opt);
    });
  }

  function filterOnSearch() {
    searchTerm = searchInput.value.trim().toLowerCase();
    renderAnimeList();
  }

  function init() {
    populateGenres();
    fetchAnimeList();

    btnAddAnime.addEventListener('click', openModal);
    modalCloseBtn.addEventListener('click', closeModal);
    modalCancelBtn.addEventListener('click', closeModal);
    animeForm.addEventListener('submit', submitForm);
    searchInput.addEventListener('input', filterOnSearch);

    btnLogout.addEventListener('click', () => {
      window.location.href = '/logout';
    });
    btnEditProfile.addEventListener('click', () => {
      window.location.href = '/edit_profile';
    });
  }

  document.addEventListener('DOMContentLoaded', init);
})();
</script>
</body>
</html>